use alloy_primitives::B256;
use anyhow::anyhow;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use adapter_sdk::api::NexusAPI;
use adapter_sdk::types::AdapterConfig;
use ethereum_adapter_host::{get_checkpoint, get_client, get_updates};
use ethereum_adapter_methods::{ETHEREUM_ADAPTER_GUEST_ELF, ETHEREUM_ADAPTER_GUEST_ID};
use helios_consensus_core::{consensus_spec::MainnetConsensusSpec, types::LightClientStore};
use helios_ethereum::consensus::Inner;
use helios_ethereum::rpc::http_rpc::HttpRpc;
use helios_ethereum::rpc::ConsensusRpc;
use nexus_core::types::{
    AccountState, AccountWithProof, InitAccount, StatementDigest, SubmitProof, TxParams,
    TxSignature, H256,
};
use nexus_core::zkvm::risczero::RiscZeroProof;
use nexus_core::zkvm::ProverMode;
use nexus_core::{
    db::NodeDB,
    types::{AppAccountId, AppId, NexusRollupPI},
};
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts, Receipt, ReceiptKind};
use serde::{Deserialize, Serialize};
use sp1_helios_primitives::types::ProofInputs;
use tree_hash::TreeHash;

#[derive(Clone, Serialize, Deserialize)]
struct AdapterStateData {
    last_height: u32,
    adapter_config: AdapterConfig,
}

#[tokio::main]
async fn main() {
    dotenv::dotenv().ok();
    run(1).await.unwrap();
}

async fn run(loop_delay_mins: u64) -> Result<(), anyhow::Error> {
    let db = NodeDB::from_path("./db");

    let adapter_state_data = if let Some(data) = db.get::<AdapterStateData>(b"adapter_state")? {
        data
    } else {
        // Initialize with default values if no data found in the database
        let adapter_config = AdapterConfig {
            app_id: AppId(1),
            elf: ETHEREUM_ADAPTER_GUEST_ELF.to_vec(),
            adapter_elf_id: StatementDigest(ETHEREUM_ADAPTER_GUEST_ID),
            vk: [0u8; 32],
            rollup_start_height: 1,
            prover_mode: ProverMode::MockProof, // TODO : change this after testing (Take from argument)
            avail_url: String::from("wss://turing-rpc.avail.so:443/ws"),
        };
        AdapterStateData {
            last_height: 0,
            adapter_config,
        }
    };

    let nexus_api = NexusAPI::new(&"http://127.0.0.1:7000");

    loop {
        let (previous_pi_and_proof) = db.get::<(NexusRollupPI, Receipt)>(b"last_proof")?;

        let last_head: u64 = match previous_pi_and_proof.as_ref() {
            Some(i) => i.0.height.into(),
            None => 6947648,
        };

        //Get checkpoint at the last head we have proof for.
        let checkpoint = get_checkpoint(last_head).await;

        //Get the client from the checkpoint.
        let client = get_client(checkpoint).await;

        let start_nexus_hash = init_account(adapter_state_data.clone(), nexus_api.clone()).await?;

        match request_update(
            client,
            last_head,
            &previous_pi_and_proof,
            AppAccountId::from(AppId(1)),
            &nexus_api,
            start_nexus_hash
        )
        .await
        {
            Ok(Some(receipt)) => {
                let last_pi: NexusRollupPI =
                    receipt.journal.decode().expect("Failed to decode last PI");

                db.put(b"last_proof", &(last_pi, receipt)).unwrap();
            }
            Ok(None) => {}
            Err(e) => {
                println!("Error: {}", e);
            }
        }
    }
}

async fn init_account(
    adapter_state_data: AdapterStateData,
    nexus_api: NexusAPI,
) -> Result<H256, anyhow::Error> {
    let range = match nexus_api.get_range().await {
        Ok(i) => i,
        Err(e) => {
            println!("{:?}", e);
            return Err(anyhow!(e));
        }
    };

    let app_account_id = AppAccountId::from(adapter_state_data.adapter_config.app_id.clone());
    let account_with_proof: AccountWithProof =
        match nexus_api.get_account_state(&app_account_id.as_h256()).await {
            Ok(i) => i,
            Err(e) => {
                println!("Error: {}", e);
                return Err(anyhow!(e));
            }
        };

    if account_with_proof.account == AccountState::zero() {
        let tx = nexus_core::types::Transaction {
            signature: TxSignature([0u8; 64]),
            params: TxParams::InitAccount(InitAccount {
                app_id: app_account_id.clone(),
                statement: StatementDigest(ETHEREUM_ADAPTER_GUEST_ID),
                start_nexus_hash: range[0],
            }),
        };
        match nexus_api.send_tx(tx).await {
            Ok(i) => {
                println!(
                    "Initiated account on nexus. AppAccountId: {:?} Response: {:?}",
                    &app_account_id, i,
                )
            }
            Err(e) => {
                println!("Error when initiating account: {:?}", e);
                return Err(anyhow!(e));
            }
        }
        
        Ok(range[0])
    } else {
        Ok(H256::from(account_with_proof.account.start_nexus_hash))
    }
}

async fn request_update(
    mut client: Inner<MainnetConsensusSpec, HttpRpc>,
    head: u64,
    prev_pi_and_proof: &Option<(NexusRollupPI, Receipt)>,
    app_id: AppAccountId,
    nexus_api: &NexusAPI,
    start_nexus_hash: H256
) -> Result<Option<Receipt>, anyhow::Error> {
    // Setup client.
    let mut sync_committee_updates = get_updates(&client).await;
    let finality_update = client.rpc.get_finality_update().await.unwrap();
    // Check if contract is up to date
    let latest_block = finality_update.finalized_header.beacon().slot;
    if latest_block <= head {
        println!("We already have proofs till here. Nothing to process.");
        return Ok(None);
    }

    if !sync_committee_updates.is_empty() {
        let nexus_api = NexusAPI::new("http://127.0.0.1:7000");

        let nexus_hash = nexus_api.get_range().await?[0];
        let next_sync_committee = B256::from_slice(
            sync_committee_updates[0]
                .next_sync_committee
                .tree_hash_root()
                .as_ref(),
        );
        println!(
            "Next sync committee according to host {:?}",
            next_sync_committee
        );

        //TODO: Check if next_sync_committee matches the PI of previous proof.

        let expected_current_slot = client.expected_current_slot();
        let inputs = ProofInputs {
            sync_committee_updates,
            finality_update,
            expected_current_slot,
            store: client.store.clone(),
            genesis_root: client.config.chain.genesis_root,
            forks: client.config.forks.clone(),
            nexus_hash,
        };

        let (prev_pi, prev_proof) = match prev_pi_and_proof {
            Some(i) => (Some(i.0.clone()), Some(i.1.clone())),
            None => (None, None),
        };

        let journal = match prev_proof.clone() {
            Some(receipt) => Some(receipt.journal.bytes),
            None => None,
        };

        let mut env_builder = ExecutorEnv::builder();
        let inputs_vec: Vec<u8> = serde_cbor::to_vec(&(
            inputs,
            prev_pi,
            Some(app_id.clone()),
            ETHEREUM_ADAPTER_GUEST_ID,
            journal,
            start_nexus_hash
        ))
        .expect("Failed to serialize inputs");
        println!("Serialized inputs: {}", inputs_vec.len());
        env_builder.write_slice(&inputs_vec);
        // .write(&inputs.sync_committee_updates)
        // .unwrap()
        // .write(&inputs.finality_update)
        // .unwrap()
        // .write(&inputs.expected_current_slot)
        // .unwrap()
        // .write_slice(&to_vec(&inputs.store).unwrap())
        // .write(&inputs.genesis_root)
        // .unwrap()
        // .write(&inputs.forks)
        // .unwrap()
        // .write(&inputs.nexus_hash)
        // .unwrap()
        // .write(&prev_pi)
        // .unwrap()
        // .write(&Some(app_id))
        // .unwrap();

        let env = if let Some(proof) = prev_proof {
            env_builder.add_assumption(proof).build().unwrap()
        } else {
            env_builder.build().unwrap()
        };

        let prover = default_prover();

        // Proof information by proving the specified ELF binary.
        // This struct contains the receipt along with statistics about execution of the guest
        let prover_opts = ProverOpts::succinct();
        let prove_info = prover
            .prove_with_opts(env, ETHEREUM_ADAPTER_GUEST_ELF, &prover_opts)
            .unwrap();

        // extract the receipt.
        let receipt = prove_info.receipt;
        let journal: NexusRollupPI = receipt.journal.decode()?;

        // Send proof to avail nexus
        let recursive_proof = RiscZeroProof(receipt.clone());
        let tx = nexus_core::types::Transaction {
            signature: TxSignature([0u8; 64]),
            params: TxParams::SubmitProof(SubmitProof {
                app_id: journal.app_id,
                nexus_hash,
                state_root: journal.state_root,
                proof: match recursive_proof.clone().try_into() {
                    Ok(i) => i,
                    Err(e) => {
                        println!("Unable to serialise proof: {:?}", e);
                        return Err(anyhow!("Unable to serialise proof"));
                    }
                },
                height: journal.height,
                data: journal.rollup_hash,
            }),
        };

        match nexus_api.send_tx(tx).await {
            Ok(i) => {
                println!(
                    "Submitted proof to update state root on nexus. AppAccountId: {:?} Response: {:?} Stateroot: {:?}",
                    &app_id, i, &H256::zero()
                )
            }
            Err(e) => {
                println!("Error when initiating account: {:?}", e);
                return Err(anyhow!(e));
            }
        }

        return Ok(Some(receipt));
    }

    Ok(None)
}
