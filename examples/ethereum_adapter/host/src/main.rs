use alloy_primitives::B256;
use anyhow::anyhow;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use adapter_sdk::api::NexusAPI;
use ethereum_adapter_host::{get_checkpoint, get_client, get_updates};
use ethereum_adapter_methods::{ETHEREUM_ADAPTER_GUEST_ELF, ETHEREUM_ADAPTER_GUEST_ID};
use helios_consensus_core::{consensus_spec::MainnetConsensusSpec, types::LightClientStore};
use helios_ethereum::consensus::Inner;
use helios_ethereum::rpc::http_rpc::HttpRpc;
use helios_ethereum::rpc::ConsensusRpc;
use nexus_core::{
    db::NodeDB,
    types::{AppAccountId, AppId, NexusRollupPI},
};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use serde::Serialize;
use sp1_helios_primitives::types::ProofInputs;
use tree_hash::TreeHash;

#[tokio::main]
async fn main() {
    dotenv::dotenv().ok();
    run(1).await.unwrap();
}

async fn run(loop_delay_mins: u64) -> Result<(), anyhow::Error> {
    let db = NodeDB::from_path("./db");
    loop {
        let (previous_pi_and_proof) = db.get::<(NexusRollupPI, Receipt)>(b"last_proof")?;

        let last_head: u64 = match previous_pi_and_proof.as_ref() {
            Some(i) => i.0.height.into(),
            None => 6947648,
        };

        //Get checkpoint at the last head we have proof for.
        let checkpoint = get_checkpoint(last_head).await;

        //Get the client from the checkpoint.
        let client = get_client(checkpoint).await;

        match request_update(
            client,
            last_head,
            &previous_pi_and_proof,
            AppAccountId::from(AppId(100)),
        )
        .await
        {
            Ok(Some(receipt)) => {
                let last_pi: NexusRollupPI =
                    receipt.journal.decode().expect("Failed to decode last PI");

                db.put(b"last_proof", &(last_pi, receipt)).unwrap();
            }
            Ok(None) => {}
            Err(e) => {
                println!("Error: {}", e);
            }
        }
    }
}

async fn request_update(
    mut client: Inner<MainnetConsensusSpec, HttpRpc>,
    head: u64,
    prev_pi_and_proof: &Option<(NexusRollupPI, Receipt)>,
    app_id: AppAccountId,
) -> Result<Option<Receipt>, anyhow::Error> {
    // Setup client.
    let mut sync_committee_updates = get_updates(&client).await;
    let finality_update = client.rpc.get_finality_update().await.unwrap();
    // Check if contract is up to date
    let latest_block = finality_update.finalized_header.beacon().slot;
    if latest_block <= head {
        println!("We already have proofs till here. Nothing to process.");
        return Ok(None);
    }

    if !sync_committee_updates.is_empty() {
        let nexus_api = NexusAPI::new("http://127.0.0.1:7000");

        let nexus_hash = nexus_api.get_range().await?[0];
        let next_sync_committee = B256::from_slice(
            sync_committee_updates[0]
                .next_sync_committee
                .tree_hash_root()
                .as_ref(),
        );
        println!(
            "Next sync committee according to host {:?}",
            next_sync_committee
        );

        //TODO: Check if next_sync_committee matches the PI of previous proof.

        let expected_current_slot = client.expected_current_slot();
        let inputs = ProofInputs {
            sync_committee_updates,
            finality_update,
            expected_current_slot,
            store: client.store.clone(),
            genesis_root: client.config.chain.genesis_root,
            forks: client.config.forks.clone(),
            nexus_hash: nexus_hash.clone(),
        };

        let (prev_pi, prev_proof) = match prev_pi_and_proof {
            Some(i) => (Some(i.0.clone()), Some(i.1.clone())),
            None => (None, None),
        };

        let mut env_builder = ExecutorEnv::builder();
        let inputs_vec: Vec<u8> = serde_cbor::to_vec(&(inputs, prev_pi, Some(app_id)))
            .expect("Failed to serialize inputs");
        println!("Serialized inputs: {}", inputs_vec.len());
        env_builder.write_slice(&inputs_vec);
        // .write(&inputs.sync_committee_updates)
        // .unwrap()
        // .write(&inputs.finality_update)
        // .unwrap()
        // .write(&inputs.expected_current_slot)
        // .unwrap()
        // .write_slice(&to_vec(&inputs.store).unwrap())
        // .write(&inputs.genesis_root)
        // .unwrap()
        // .write(&inputs.forks)
        // .unwrap()
        // .write(&inputs.nexus_hash)
        // .unwrap()
        // .write(&prev_pi)
        // .unwrap()
        // .write(&Some(app_id))
        // .unwrap();

        let env = if let Some(proof) = prev_proof {
            env_builder.add_assumption(proof).build().unwrap()
        } else {
            env_builder.build().unwrap()
        };

        let prover = default_prover();

        // Proof information by proving the specified ELF binary.
        // This struct contains the receipt along with statistics about execution of the guest
        let prove_info = prover.prove(env, ETHEREUM_ADAPTER_GUEST_ELF).unwrap();

        // extract the receipt.
        let receipt = prove_info.receipt;

        return Ok(Some(receipt));
    }

    Ok(None)
}
